<#@ template language="C#" linePragmas="false" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
// <auto-generated>
// THIS CODE FILE IS GENERATED BY IndirectX.TypeGenerator.
// DO NOT CHANGE IT.
// </auto-generated>
#nullable enable
<# foreach(var import in Setting.ImportNamespaces) { #>
using <#= import #>;
<# } #>
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using <#= Setting.Namespace #>.Interop;

namespace <#= Setting.Namespace #>
{
    [Guid("<#= Model.Guid #>")]
    <#= Model.Modifier #> unsafe partial class <#= Model.Name #> : <#= Model.ParentName #>
	{
        private ref readonly <#= Model.Name #>Vtbl VtblRef
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => ref Unsafe.AsRef<<#= Model.Name #>Vtbl>(*(void**)ComPtr.Native);
        }

	    public <#= Model.Name #>(ComPtr nativePtr, bool addRef = false) : base(nativePtr, addRef) { }
<#    foreach (var method in Model.Methods)
	  { #>
<#     if (method.Delete) #>
<#     { #>
        // Deleted method <#= method.SourceName #>
<#     } #>
<#     else #>
<#     { #>

        <#= method.Modifier #> <#= method.ManagedReturnType #> <#= method.Name #>(<#= method.ParameterText #>)
        {
<#        foreach (var ps in method.Prestatements)
          { #>
            <#= ps #>
<#        } #>
<#        foreach (var bs in method.BlockStatements)
          { #>
            <#= bs #>
<#        } #>
            {
                <# if (method.ReturnNative) { #>return <# } #>VtblRef.<#= method.Name #>(ComPtr<#= method.ArgText #>)<# 
			if (!method.ReturnNative && method.NativeReturnType == "HResult") { #>.HandleResult()<# } #>;
<#          if (!method.ReturnNative && method.Outputs.Count() > 0)
            { #>
			    return (<#= method.ReturnText #>);
<#          } #>
            }
        }
<#      if (method.Parameters.Any(p => p.IsOptional))
        { #>

        <#= method.Modifier #> <#= method.ManagedReturnType #> <#= method.Name #>(<#= method.OptionalParameterText #>)
        {
<#        foreach (var ps in method.OptionalPrestatements)
          { #>
            <#= ps #>
<#        } #>
<#        foreach (var bs in method.OptionalBlockStatements)
          { #>
            <#= bs #>
<#        } #>
            {
                <# if (method.ReturnNative) { #>return <# } #>VtblRef.<#= method.Name #>(ComPtr<#= method.OptionalArgText #>)<# 
			if (!method.ReturnNative && method.NativeReturnType == "HResult") { #>.HandleResult()<# } #>;
<#          if (!method.ReturnNative && method.Outputs.Count() > 0)
            { #>
			    return (<#= method.ReturnText #>);
<#          } #>
            }
        }
<#      } #>
<#     } #>
<#    }
      foreach (var (name, type, hasSetter) in Model.Properties)
      { 
        if (hasSetter)
        { #>

        public <#= type #> <#= name #>
        {
            get => Get<#= name #>();
            set => Set<#= name #>(value);
        }
<#      }
        else 
        { #>

        public <#= type #> <#= name #> => Get<#= name #>();
<#      } #>
<#    } #>
	}
}

namespace <#= Setting.Namespace #>.Interop
{
    [StructLayout(LayoutKind.Sequential)]
	<#= Model.Modifier #> unsafe struct <#= Model.Name #>Vtbl
	{
	    internal <#= Model.ParentName #>Vtbl Base;
<#    foreach (var method in Model.Methods)
      { #>
        internal delegate* unmanaged[Stdcall]<ComPtr, <#
		  foreach (var p in method.Parameters)
		  {
			#><#= p.NativeType #>, <#
	      } #><#= method.NativeReturnType #>> <#= method.Name #>;
<#    } #>
	}
}
